package net.zonixmc.exploits;

import net.zonixmc.exploits.cache.CacheController;
import net.zonixmc.exploits.check.creative.CreativeA;
import net.zonixmc.exploits.check.creative.CreativeB;
import net.zonixmc.exploits.check.creative.CreativeC;
import net.zonixmc.exploits.check.flood.FloodA;
import net.zonixmc.exploits.check.flood.FloodB;
import net.zonixmc.exploits.check.flood.FloodC;
import net.zonixmc.exploits.check.fly.FlyA;
import net.zonixmc.exploits.check.fly.FlyB;
import net.zonixmc.exploits.check.fly.FlyC;
import net.zonixmc.exploits.check.generic.GenericA;
import net.zonixmc.exploits.check.generic.GenericB;
import net.zonixmc.exploits.check.generic.GenericC;
import net.zonixmc.exploits.check.payload.PayloadA;
import net.zonixmc.exploits.check.payload.PayloadB;
import net.zonixmc.exploits.check.payload.PayloadC;
import net.zonixmc.exploits.check.place.PlaceA;
import net.zonixmc.exploits.check.place.PlaceB;
import net.zonixmc.exploits.check.window.WindowA;
import net.zonixmc.exploits.check.window.WindowB;
import net.zonixmc.exploits.listener.PlayerConnectionListener;
import net.zonixmc.exploits.util.InjectorUtil;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import org.bukkit.Bukkit;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.plugin.java.JavaPlugin;

import java.io.File;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;

public class AntiExploitsPlugin extends JavaPlugin {

    @Override
    public void onEnable() {

        CacheController.init(this);

        Bukkit.getPluginManager().registerEvents(new PlayerConnectionListener(), this);

        fixWE();
        registerChecks();

        Bukkit.getOnlinePlayers().forEach(InjectorUtil::injectHandlers);

        Bukkit.getLogger().log(Level.INFO, "Plugin started successfully!");

    }

    @Override
    public void onDisable() {

        HandlerList.unregisterAll(this);
        Bukkit.getOnlinePlayers().forEach(InjectorUtil::unInjectHandlers);

        Bukkit.getLogger().log(Level.INFO, "The plugin has been successfully shut down!");

    }

    private void registerChecks() {

        Set<Class<?>> checks = Sets.newHashSet(

                CreativeA.class, CreativeB.class, CreativeC.class,
                FloodA.class, FloodB.class, FloodC.class,
                FlyA.class, FlyB.class, FlyC.class,
                GenericA.class, GenericB.class, GenericC.class,
                PayloadA.class, PayloadB.class, PayloadC.class, PayloadC.class,
                PlaceA.class, PlaceB.class,
                WindowA.class, WindowB.class

        );

        checks.forEach(context -> {

            try { Bukkit.getPluginManager().registerEvents((Listener) context.newInstance(), this); }

            catch (Exception exception) { exception.printStackTrace(); }

        });

    }

    private void fixWE() {

        File file = new File("plugins/FastAsyncWorldEdit", "commands.yml");

        if (!file.exists()) return;

        YamlConfiguration yamlConfiguration = YamlConfiguration.loadConfiguration(file);
        List<String> targetOffSetAliases = yamlConfiguration.getStringList("BrushOptionsCommands.targetoffset.aliases");
        List<String> calcAliases = yamlConfiguration.getStringList("UtilityCommands./calc.aliases");

        if (targetOffSetAliases.size() > 0 || calcAliases.size() > 0) {

            yamlConfiguration.set("BrushOptionsCommands.targetoffset.aliases", Lists.newArrayList());
            yamlConfiguration.set("UtilityCommands./calc.aliases", Lists.newArrayList());

            try { yamlConfiguration.save(file); }

            catch (Exception ignored) {}

            Bukkit.shutdown();

        }

    }

}
